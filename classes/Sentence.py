from typing import List, Dict
import re

from Forms import Form
from Members import Member
from syn import Syn
from morph import Morph

from Protagonist import Protagonist
from Word import Word

class Sentence:
    """
    Class object representing a sentence
    """

    def __init__(self, sentence: str, anaphors: Dict[str, str], protg: Protagonist):
        self.nodes = Syn.get_sentence_nodes(sentence)
        self.anaphors = anaphors
        self.words = self._create_words_objects()
        self.root = self._find_root()
        self.protg = protg
        self._add_parents()
        self.new_sentence = sentence
        # self.resolved_subject = ?

    def _create_words_objects(self) -> List[Word]:
        """
        Method creates a list of Word objects from nodes generated by SET.
        """
        words = []
        for node in self.nodes:
            index, word_form, parent_idx, _, member = node
            word = Word(int(index),
                        word_form,
                        self._assign_member(word_form, member),
                        int(parent_idx),
                        [],
                        {},  # TODO self.anaphors[word_form],
                        False)  # TODO direct speech, anaphors
            words.append(word)
        self._add_dependencies(words)

        return words

    def _add_dependencies(self, words: List[Word]) -> None:
        """
        Takes the undone list of Word objects and updates it by adding dependending Word objects to dependencies.
        """
        for i, node in enumerate(self.nodes):
            dep_idx = int(node[2])
            words[dep_idx].dependents.append(words[i])

    def _add_parents(self) -> None:
        for word in self.words:
            if word.parent_idx == -1:
                continue
            word.parent_node = self.words[word.parent_idx]

    def _find_root(self) -> Word:
        """
        Method takes the Word objects list and finds the root of sentence tree.
        """
        for word in self.words:
            if word.parent_idx == -1:
                return word

    def _is_word_predicate(self, word_form: str, member) -> bool:
        if len(member) > 0:
            return False
        tag = Morph.get_tag(word_form)
        return tag and len(tag) > 1 and tag[1] == "5"

    def _is_word_cond(self, word_form: str, member) -> bool:
        if len(member) > 0:
            return False
        lemma = Morph.get_lemma(word_form)
        return lemma == "kdyby" or lemma == "aby"

    def _assign_member(self, word_form: str, member_input: str) -> Member:
        if self._is_word_predicate(word_form, member_input):
            return Member.pred
        if self._is_word_cond(word_form, member_input):
            return Member.y
        if Member.has_value(member_input):
            return Member(member_input)
        return Member.other

    def rephrase(self, form: Form):
        # TODO add protagonist as subject in ichtoer
        new_forms = []
        for word in self.words:
            if word.is_real_word():
                if form == Form.ICH:
                    word.ich_to_er(self.protg)
                elif form == Form.ER:
                    pass  # TODO
                new_forms.append(word.new_form)

        self.new_sentence = " ".join(new_forms)




